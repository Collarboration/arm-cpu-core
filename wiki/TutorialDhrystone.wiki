#labels tutorial,dhrystone,MIPS,ARM,CPU,core
#This is a simple tutorial to guide how to get dhrystone MIPS of this arm-cpu-core.



This ARMv4-compatible CPU core supports most general ARMv4 architecture. It doesn’t has the function of thumb instruction set and coprocessor interface. It has an elegant description and the verilog file of it has a short length: less than 1800 lines. If you want to develop SoC design based on ARM architecture, it is not easy to get a realy ARM cpu core, so this ARMv4-compatible CPU core will be a good method to develop your own SoC design based on most popular ARM architecture.

I am an engineer and have a good skill in writing verilog. I think it is a good challenge for me to make ARMv4 architecture easy to implement in verilog. I don’t know how to start my introduction of my project. Anyway, I have built a simulation to measure dhrystone MIPS of this ARMv4-compatible CPU core, it is a good start to describe my process how to make it.

This simulation needs a simplest system to run dhrystone manchine code. I have made one just like below. It has a clock source; a timer to supply real time; a ROM module to store machine code; a RAM module; a virtual UART to display dhrystone’s output.


 
In the digram, “ARM CPU” core is my ARMv4-compatiable CPU core, and the rest is described in my testbench file: “tb_dhrystone.v”. Let’s review it. You can open it.

The first line is “module tb_dhrystone;”. It is a common start of a testbench verilog file. Following is like that:
reg         clk;

initial clk = 1'b0;

always clk = #500 ~clk;
It gives a clock source of 1 MHz. Why is 1MHz, not other? Because “DMIPS/MHz” needs it. If I use 1 MHz clock, I will easy to get “DMIPS/MHz”.
Then, a reset signal is needed to reset every register. 
reg         rst;
initial begin
rst = 1'b1;
#1000 rst = 1'b0;
end
 This reset signal has a length of 1 us. 

It is obvious that dhrystone measure needs a real timer. In KEIL’s directory:” C:\Keil\ARM\Examples\DHRY”, “timer.c” defines how to generate this timer:
long timeval = 0;

/* Timer Counter 0 Interrupt executes each 10ms @ 40 MHz Crystal Clock        */
__irq void IRQ_Handler (void) {
  timeval++;
//  AIC_EOICR = TC0_SR;                          /* end interrupt               */
}

Yes, it needs an IRQ interrupt every 10 ms. So I makes a counter, which counts to 10ms/1us(1MHz)=10000.


integer irq_cnt = 0;

always @ ( posedge clk )
if ( irq_cnt==9999 )
    irq_cnt <= 0;
else
    irq_cnt <= irq_cnt + 1'b1;
	
wire irq;
assign irq = (irq_cnt==9999);	


ROM module is important to testbench. It contains machine codes, which is generated by KEIL software. I names it “DHRY.bin”. I use verilog function: $readmemh to load it from “DHRY.bin” to “reg [7:0] rom_contain [32767:0]”.
reg [7:0] rom_contain [32767:0];

initial begin
   $readmemh("DHRY.bin", rom_contain);
end

Now, machine code is stored in “rom_contain”. The CPU core will fetch it if it needs to. ARM CPU core will send two signals “rom_en/rom_addr[31:0]” to fetch machine code. If “rom_en” is asserted, it means that instruction stored in “rom_addr[31:0]” will be fetched.
Following is the description of fetching:
wire            rom_en;
wire [31:0]     rom_addr;
reg  [31:0]     rom_data;
always @ ( posedge clk )
if ( rom_en )
    rom_data <= {rom_contain[rom_addr+3],rom_contain[rom_addr+2],rom_contain[rom_addr+1],rom_contain[rom_addr]};
else;